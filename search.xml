<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【java 数据结构】还不会二叉树？一篇搞定二叉树</title>
      <link href="/2020/04/17/java-shu-ju-jie-gou-huan-bu-hui-er-cha-shu-yi-pian-gao-ding-er-cha-shu/"/>
      <url>/2020/04/17/java-shu-ju-jie-gou-huan-bu-hui-er-cha-shu-yi-pian-gao-ding-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<p>二叉树是我们常见的数据结构之一，在学习二叉树之前我们需要知道什么是树，什么是二叉树，本篇主要讲述了二叉树，以及二叉树的遍历。</p><h2 id="你能get到的知识点？"><a href="#你能get到的知识点？" class="headerlink" title="你能get到的知识点？"></a>你能get到的知识点？</h2><p>1、树的介绍<br>2、二叉树的介绍<br>3、二叉树遍历的四种方法<br>4、牛客题目：反转二叉树</p><p>@[TOC]</p><p><img src="https://img-blog.csdnimg.cn/20200417095221714.jpg" alt=""></p><h2 id="一、知识预备"><a href="#一、知识预备" class="headerlink" title="一、知识预备"></a>一、知识预备</h2><h3 id="1、树"><a href="#1、树" class="headerlink" title="1、树"></a>1、树</h3><p><strong>树</strong>（Tree）是n（n&gt;=0)个结点的有限集。</p><p>数据结构中的树可以看作一个倒立的树，他的‘根’在上面，他的’叶子’在下面。</p><pre><code class="mermaid">graph TD4--&gt;24--&gt;72--&gt;12--&gt;37--&gt;67--&gt;9 </code></pre><h3 id="2、树的相关术语介绍"><a href="#2、树的相关术语介绍" class="headerlink" title="2、树的相关术语介绍"></a>2、树的相关术语介绍</h3><ul><li>1、树的结点（node）：包含一个数据元素及若干指向子树的分支；</li><li>2、孩子结点（child node）：结点的子树的根称为该结点的孩子，对于结点4来说，结点2和结点7就是结点4的孩子结点；</li><li>3、双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；</li><li>4、兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点；</li><li>5、祖先结点: 从根到该结点的所经分支上的所有结点</li><li>6、子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙</li><li>7、结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；</li><li>8、树的深度：树中最大的结点层，该树的深度为三，因为他只有三层。</li><li>9、结点的度：结点子树的个数</li><li>10、树的度： 树中最大的结点度。</li><li>11、叶子结点：也叫终端结点，是度为 0 的结点，例如结点1、2、6、9，都是叶子结点；</li><li>12、分枝结点：度不为0的结点；</li><li>13、有序树：子树有序的树，如：家族树；</li><li>14、无序树：不考虑子树的顺序；</li></ul><h3 id="1、二叉树"><a href="#1、二叉树" class="headerlink" title="1、二叉树"></a>1、二叉树</h3><p><strong>二叉树</strong>（Binary Tree）是每个结点最多有两个子树的树结构。所以二叉树也是一种特殊的树。</p><p>通常我们将二叉树的子树被称作“左子树”（left subtree）和“右子树”（right subtree）。</p><p>二叉树常被用于实现二叉查找树和二叉堆。<br><img src="https://img-blog.csdnimg.cn/20200415095939408.png" alt=""><br>由此可以看出，一棵二叉树，他的每个节点最多只有两个结点，也就是结点的度小于等于二，即取0、1、2。</p><h3 id="2、二叉树类型"><a href="#2、二叉树类型" class="headerlink" title="2、二叉树类型"></a>2、二叉树类型</h3><ol><li>满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。<br><img src="https://img-blog.csdnimg.cn/20200415100335118.png#pic_center" alt=""></li><li>完全二叉树：若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。<br>简单来说：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。<br><img src="https://img-blog.csdnimg.cn/20200415100407802.png#pic_center" alt=""></li></ol><ol start="3"><li><p>平衡二叉树：平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><h2 id="二、二叉树实操（我没有说脏话）"><a href="#二、二叉树实操（我没有说脏话）" class="headerlink" title="二、二叉树实操（我没有说脏话）"></a>二、二叉树实操（我没有说脏话）</h2><h3 id="1、定义二叉树的结点"><a href="#1、定义二叉树的结点" class="headerlink" title="1、定义二叉树的结点"></a>1、定义二叉树的结点</h3><p>定义二叉树每一个节点的结构，他拥有左右子叶，并且本身拥有一个值val,定义一个构造函数，多个结点组合在一起就是一个二叉树。</p><pre><code class="java"> /**  * Definition for binary tree  */ public static class TreeNode {   //定义该结点值   int val;   //定义左结点   TreeNode left;   //定义右结点   TreeNode right;   //定义一个构造函数   TreeNode(int x) { val = x; } }</code></pre><p>例图：以下将以该例图进行解说</p><pre><code class="mermaid">graph TD4--&gt;24--&gt;72--&gt;12--&gt;37--&gt;67--&gt;9</code></pre><h3 id="2、遍历二叉树（四种方法）"><a href="#2、遍历二叉树（四种方法）" class="headerlink" title="2、遍历二叉树（四种方法）"></a>2、遍历二叉树（四种方法）</h3><p>遍历二叉树主要有四种方法：①：前序遍历 ②：中序遍历 ③：后序遍历 ④：层序遍历</p></li></ol><p>需要事先说明的就是前三种遍历，就是根节点的访问顺序不同，但是访问左右节点的顺序仍然是先访问左结点，再访问右结点。</p><p>①：前序遍历</p><blockquote><p>1、访问根节点；<br>2、访问当前节点的左子树；<br>3、访问当前节点的右子树；<br>就是先从根节点出发，先访问根节点，然后访问根结点的左子树，若该左子树的根节点上存在左子树，则访问其左子树，否则，访问其右子树，依次类推。</p></blockquote><p>以上图为例，</p><ol><li>先找到根节点，读取4，</li><li>该结点还有左子树，访问其左子树的根节点，读取2，</li><li>结点2，还有左子树，读取1，</li><li>结点1没有左子树也没有右子树，返回上一层，访问结点2的右子树，读取3，</li><li>这时候应该访问3的左右子树，但是没有，返回上一层，此时结点2的左右子树都已经读取完，返回上一层，读取结点4的右子树，读取7，</li><li>访问结点7的左子树，读取6，</li><li>结点6没有左右子树，返回上一层，访问结点7的右子树，读取9，</li><li>结点9没有左右子树，这时候该二叉树已经遍历完成。</li></ol><p>所以访问到的顺序为：<code>4    2    1    3    7    6    9</code>    </p><p>②：中序遍历 </p><blockquote><p>1、访问当前节点的左子树；<br>2、访问根节点；<br>3、访问当前节点的右子树；<br>遍历思想与前序差不多，只不过将读取根节点放在读取左结点之后、右结点之前</p></blockquote><p>③：后序遍历 </p><blockquote><p>1、访问当前节点的左子树；<br>2、访问当前节点的右子树；<br>3、访问根节点；<br>遍历思想与前序差不多，只不过将读取根节点放在读取左结点之后、右结点之后</p></blockquote><p>④：层序遍历</p><blockquote><p>按照二叉树的层级结构从左至右依次遍历结点<br><strong>算法思路</strong>：定义一个队列，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200415100654515.png#pic_center" alt=""></p><ol><li>根节点4入队，</li><li>根节点4出队，访问结点4的左右结点（2，7），依次入队，</li><li>结点2出队，访问结点2的左右结点（1，3），依次入队，</li><li>结点1出队，无子结点，无需入队，</li><li>结点3出队，无子结点，无需入队，</li><li>结点6出队，无子结点，无需入队，</li><li>结点9出队，无子结点，无需入队，</li><li>队列为空，遍历完成。</li></ol><p>最后访问顺序为：<code>4    2    7    1    3    6    9</code></p><p>代码实现：</p><pre><code class="java">    /**     * 先序遍历（递归）     * @param node     */    public void previous(TreeNode node) {        if (node == null) {            return;        }        System.out.print(node.val+"\t");        this.previous(node.left);        this.previous(node.right);    }    /**     * 中序遍历（递归）     * @param node     */    public void middle(TreeNode node) {        if (node == null) {            return;        }        this.middle(node.left);        System.out.print(node.val+"\t");        this.middle(node.right);    }    /**     * 后序遍历（递归）     * @param node     */    public void next(TreeNode node) {        if (node == null) {            return;        }        this.next(node.left);        this.next(node.right);        System.out.print(node.val+"\t");    }     /**     * 遍历二叉树     * 层序遍历（非递归）     * @param node     */    public void bfs(TreeNode node){        if (node == null) {            return;        }        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.add(node);        while (!queue.isEmpty()){            TreeNode current = queue.poll();            System.out.print(current.val + "\t");            //如果当前节点的左节点不为空入队            if(current.left != null)            {                queue.offer(current.left);            }            //如果当前节点的右节点不为空，把右节点入队            if(current.right != null)            {                queue.offer(current.right);            }        }    }</code></pre><pre><code>遍历结果：1、前序遍历：4    2    1    3    7    6    9    2、中序遍历：1    2    3    4    6    7    9    3、后序遍历：1    3    2    6    9    7    4    4、层序遍历：4    2    7    1    3    6    9    </code></pre><p>在这里附上前三种方法的非递归方法，感兴趣的小伙伴可以研究研究。<br><strong>附：非递归方法</strong><br>主要实现是依靠<strong>栈</strong>来实现</p><pre><code class="java">    /**     * 先序遍历非递归     * @param node     */    public void previous1(TreeNode node) {        if (node == null) {            return;        }        Stack&lt;TreeNode&gt; queue = new Stack&lt;&gt;();        queue.add(node);        while (!queue.isEmpty()) {            TreeNode current = queue.pop();            while(current!=null) {                System.out.print(current.val + "\t");                if (current.right!=null){                    queue.push(current.right);                }                current = current.left;            }        }    }     /**     * 中序遍历（非递归）     * @param node     */    public void middle1(TreeNode node) {        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        while (!stack.isEmpty() || node !=null) {            while (node != null){                stack.push(node);                node = node.left;            }            node = stack.pop();            System.out.print(node.val + "\t");            node = node.right;        }    }    /**     * 后序遍历（非递归）     * @param node     */    public void next1(TreeNode node) {        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;();        while (!stack.isEmpty() || node !=null) {            while (node != null){                stack.push(node);                stack1.push(0);                node = node.left;            }            while (!stack.isEmpty() &amp;&amp; stack1.peek() == 1) {                stack1.pop();                System.out.print(stack.pop().val + "\t");            }            if (!stack.isEmpty()) {                stack1.pop();                stack1.push(1);                node = stack.peek();                node = node.right;            }        }    }</code></pre><h2 id="三、小试牛刀"><a href="#三、小试牛刀" class="headerlink" title="三、小试牛刀"></a>三、小试牛刀</h2><h3 id="leetcode题目：反转二叉树"><a href="#leetcode题目：反转二叉树" class="headerlink" title="leetcode题目：反转二叉树"></a>leetcode题目：反转二叉树</h3><p>原来的二叉树：</p><pre><code class="mermaid">graph TD4--&gt;24--&gt;72--&gt;12--&gt;37--&gt;67--&gt;9</code></pre><p>经过算法，需要转换为：</p><pre><code class="mermaid">graph TD4--&gt;74--&gt;22--&gt;32--&gt;17--&gt;97--&gt;6</code></pre><p><strong>解法：</strong><br>二叉树的遍历有四种方法，那么，该题解法也至少有四种，如果读懂了上面的遍历算法，那么这道题简直轻而易举。</p><p>主要思路：就是遍历某一结点时，也就是在原来输出该节点的操作换成将其结点的左右结点交换位置。</p><pre><code class="java">/**     * 反转二叉树     * 前序反转     * @param node     */    public void invertTree_previous(TreeNode node){        if (node == null){            return;        }        TreeNode node1 = node.left;        node.left = node.right;        node.right = node1;        this.invertTree_previous(node.left);        this.invertTree_previous(node.right);    }    /**     * 反转二叉树     * 中序反转     * @param node     */    public void invertTree_middle(TreeNode node){        if (node == null){            return;        }        this.invertTree_middle(node.left);        TreeNode node1 = node.left;        node.left = node.right;        node.right = node1;        this.invertTree_middle(node.left);    }    /**     * 反转二叉树     * 后序序反转     * @param node     */    public void invertTree_next(TreeNode node){        if (node == null){            return;        }        this.invertTree_next(node.left);        this.invertTree_next(node.right);        TreeNode node1 = node.left;        node.left = node.right;        node.right = node1;    }    /**     * 反转二叉树     * 层序反转     * @param node     */    public void invertTree_bfs(TreeNode node){        if (node == null) {            return;        }        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.add(node);        while (!queue.isEmpty()){            TreeNode current = queue.poll();            TreeNode node1 = current.left;            current.left = current.right;            current.right = node1;            //如果当前节点的左节点不为空入队            if(current.left != null)            {                queue.offer(current.left);            }            //如果当前节点的右节点不为空，把右节点入队            if(current.right != null)            {                queue.offer(current.right);            }        }    }</code></pre><p>答案：</p><pre><code class="java">1、转换前前序遍历：4    2    1    3    7    6    9    中序遍历：1    2    3    4    6    7    9    后序遍历：1    3    2    6    9    7    4    层次遍历：4    2    7    1    3    6    9    2、转换后前序遍历：4    7    9    6    2    3    1    中序遍历：9    7    6    4    3    2    1    后序遍历：9    6    7    3    1    2    4    层次遍历：4    7    2    9    6    3    1    </code></pre><p>源码获取：关注公众号：<strong>博奥思园</strong>，回复：<strong>数据结构二叉树</strong></p><p><strong>你的支持是我前进的最大动力</strong></p><blockquote><p>参考：<br>1、 <a href="https://www.cnblogs.com/ysocean/p/8032642.htm" target="_blank" rel="noopener">Java数据结构和算法（十）——二叉树</a><br>2、<a href="https://blog.csdn.net/bingfeilongxin/article/details/88422192" target="_blank" rel="noopener">二叉树的四种遍历算法</a><br>3、<a href="https://www.cnblogs.com/liuyang0/p/6271331.html" target="_blank" rel="noopener">Java实现二叉树的前序、中序、后序、层序遍历（非递归方法）</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【python人脸识别】使用opencv识别图片中的人脸</title>
      <link href="/2020/04/06/python-ren-lian-shi-bie-shi-yong-opencv-shi-bie-tu-pian-zhong-de-ren-lian/"/>
      <url>/2020/04/06/python-ren-lian-shi-bie-shi-yong-opencv-shi-bie-tu-pian-zhong-de-ren-lian/</url>
      
        <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p><code>OpenCV</code>是一个基于BSD许可（开源）发行的跨平台计算机视觉库</p><blockquote><p>为什么有OpenCV？ 计算机视觉市场巨大而且持续增长，且这方面没有标准API，如今的计算机视觉软件大概有以下三种：<br>1、研究代码（慢，不稳定，独立并与其他库不兼容）<br>2、耗费很高的商业化工具（比如Halcon, MATLAB+Simulink）<br>3、依赖硬件的一些特别的解决方案（比如视频监控，制造控制系统，医疗设备）这是如今的现状，而标准的API将简化计算机视觉程序和解决方案的开发，OpenCV致力于成为这样的标准API。<br>OpenCV致力于真实世界的实时应用，通过优化的C代码的编写对其执行速度带来了可观的提升，并且可以通过购买Intel的IPP高性能多媒体函数库（Integrated<br>Performance<br>Primitives）得到更快的处理速度。右图为OpenCV与当前其他主流视觉函数库的性能比较。<br>——-百度百科</p></blockquote><p>所以说opencv就是做图像处理的，而我们要实现的人脸识别，<code>opencv</code>库是必不可少的。<br><strong>原理</strong>：opencv是以图片中心为初始点，以一个缩放因子进行慢慢的缩放，在范围内进行识别，缩放因子必须适宜，太大可能会导致识别不出来</p><h2 id="1、下载库"><a href="#1、下载库" class="headerlink" title="1、下载库"></a>1、下载库</h2><pre><code class="c">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python</code></pre><h2 id="2、引入依赖"><a href="#2、引入依赖" class="headerlink" title="2、引入依赖"></a>2、引入依赖</h2><p>opencv的引入不是直接引入opencv，而是引入cv2</p><pre><code class="c">import cv2</code></pre><h2 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h2><pre><code class="c">my = cv2.imread('img/my.jpg')face_detector = cv2.CascadeClassifier("haarcascade_frontalface_alt.xml")faces = face_detector.detectMultiScale(my)for x,y,w,h in faces:    cv2.rectangle(my,pt1=(x,y),pt2=(x+w,y+h),color=[0,0,225],thickness=2)cv2.imshow("my",my)cv2.waitKey(0)cv2.destroyAllWindows()</code></pre><p><strong>注意:</strong> haarcascade_frontalface_alt.xml文件时python安装目录下Lib\site - packages\cv2\data，需要将该文件复制到项目内，不复制的话需要绝对路径。<br><strong>问题：</strong><br>描述:当图片太大或者分辨过高时，可能会遇到只能显示图片的部分<br>解决：加入代码<code>my = cv2.resize(my,None,fx=0.5,fy=0.5)</code>或者<code>cv2.namedWindow('my', cv2.WINDOW_NORMAL)</code> 不过有其他显示问题，可能会导致图片显示变形</p><h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><pre><code class="python">my = cv2.imread('img/my.jpg')my = cv2.resize(my,None,fx=0.5,fy=0.5)# 人脸特征数据的数据包face_detector = cv2.CascadeClassifier("haarcascade_frontalface_alt.xml")# 图片进行人脸数据对比# scaleFactor:缩放因子，默认1.3，# minNeighbors:最小邻居，默认为3faces = face_detector.detectMultiScale(my)# print(faces)for x,y,w,h in faces:    # pt1：人脸左上角点    # pt2：人脸右下角点    cv2.rectangle(my,pt1=(x,y),pt2=(x+w,y+h),color=[0,0,225],thickness=2)# cv2.namedWindow('my', cv2.WINDOW_NORMAL)cv2.imshow("my",my)cv2.waitKey(0)cv2.destroyAllWindows()</code></pre><h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><p><img src="https://img-blog.csdnimg.cn/20200226192647121.png" alt="效果图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【python爬虫实战】使用词云分析来分析豆瓣影评数据</title>
      <link href="/2020/04/06/python-pa-chong-shi-zhan-shi-yong-ci-yun-fen-xi-lai-fen-xi-dou-ban-ying-ping-shu-ju/"/>
      <url>/2020/04/06/python-pa-chong-shi-zhan-shi-yong-ci-yun-fen-xi-lai-fen-xi-dou-ban-ying-ping-shu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>制作词云的步骤：<br>1、从文件中读取数据<br>2、根据数据追加在一个字符串里面，然后用jieba分词器将评论分开<br>3、设置WordCloud词云参数<br>4、保存最后的结果</p><p>数据：<a href="https://blog.csdn.net/qq_41929184/article/details/104522680" target="_blank" rel="noopener">使用爬取的豆瓣影评数据</a></p><h3 id="第一步：引入依赖库"><a href="#第一步：引入依赖库" class="headerlink" title="第一步：引入依赖库"></a>第一步：引入依赖库</h3><pre><code class="python"># 1、表格库import csv# 2、jieba分词器import jieba# 3、算法运算库import numpy# 4、图像库from PIL import Image# 5、词云库from wordcloud import WordCloud</code></pre><h3 id="第二步：读取数据"><a href="#第二步：读取数据" class="headerlink" title="第二步：读取数据"></a>第二步：读取数据</h3><pre><code class="python"> stars = ("很差","较差","还行","推荐","力荐")    comments = []    with open("files/douban.csv","r",encoding="utf-8") as file:        reader = csv.reader(file)        for i in reader:            if i[1] not in stars:                pass            else:                comments.append(i)        file.close()</code></pre><h3 id="第三步：解析数据并保存"><a href="#第三步：解析数据并保存" class="headerlink" title="第三步：解析数据并保存"></a>第三步：解析数据并保存</h3><pre><code class="python">str = ""    for i in data:        str+=i[2]    cutWord = " ".join(jieba.cut(str))    bgImg = numpy.array(Image.open("files/a.jpg"))    cloud = WordCloud(        font_path="C:\Windows\Fonts\STZHONGS.TTF",        background_color="white",        mask=bgImg    ).generate(cutWord)    cloud.to_file("ciyun.png")</code></pre><h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><p>模型：<br><img src="https://img-blog.csdnimg.cn/20200226185716995.jpg" alt="模型"><br>效果：<img src="https://img-blog.csdnimg.cn/20200226185748680.png" alt="效果"></p><h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><pre><code class="python"># 1、表格库import csv# 2、jieba分词器，将一句话的词语分离出来# 1)、控制台输入：pip install jieba# 2)、左上角 file--&gt;settings---&gt;项目# 3)、清华园下载方式（在控制台）# pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba# 阿里# pip install jieba -i  http://mirrors.aliyun.com/pypi/simple/import jieba# 3、算法运算库# 控制台输入：pip install numpy# pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpyimport numpy# 4、图像库# 控制台输入：pip install pillow# pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pillowfrom PIL import Image# 5、词云库# 控制台输入：pip install WordCloud# pip install -i https://pypi.tuna.tsinghua.edu.cn/simple WordCloudfrom wordcloud import WordCloud# 定义函数，将数据从表格里读取出来def getDataFromCsv():    # 设置星级等级    stars = ("很差","较差","还行","推荐","力荐")    # 设置空列表，装从表格里面读出来的所有数据    comments = []    # 打开表格，"r"读取模式  读取数据    with open("files/douban.csv","r",encoding="utf-8") as file:        # 表格操作读数据        reader = csv.reader(file)        # 遍历表格里得到所有数据     [用户名,星级,评论]        for i in reader:            # 如果没有星级            if i[1] not in stars:                # 数据无效，忽略不处理                pass            else:                # 数据有效，装入数组                comments.append(i)        # print(comments)        file.close()    # 将装有数据的列表返回出来    return comments# 定义函数，将解析的评论做成词云def getWordCloud():    # 调用函数：得到表格中所有的数据    data = getDataFromCsv()    # 定义空的字符串，把所有的评论装进来    str = ""    # 遍历所有的数据    for i in data:        # [用户名, 星级, 评论]        str+=i[2]    # print(str)    # 通过jieba分词器将评论里面的词语用空格分离出来    cutWord = " ".join(jieba.cut(str))    # print(cutWord)    # 读取图片模型    bgImg = numpy.array(Image.open("files/a.jpg"))    # 准备词云参数    cloud = WordCloud(        # 文字的路径：本地的系统文件路径        font_path="C:\Windows\Fonts\STZHONGS.TTF",        # 生成词云的图片背景        background_color="white",        # 参考图片（参数，没有引号）        mask=bgImg    ).generate(cutWord)    # 将做成的结果生成图片    cloud.to_file("ciyun.png")</code></pre><blockquote><p>问题：安装wordcloud出错，离线安装也出错，<br>参考：<a href="https://blog.csdn.net/xiuxiuen_michelle/article/details/81080694" target="_blank" rel="noopener">https://blog.csdn.net/xiuxiuen_michelle/article/details/81080694</a><br>解决：在 <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud</a> 下载对应版本的库</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【python爬虫实战】爬取豆瓣影评数据</title>
      <link href="/2020/04/06/python-pa-chong-shi-zhan-pa-qu-dou-ban-ying-ping-shu-ju/"/>
      <url>/2020/04/06/python-pa-chong-shi-zhan-pa-qu-dou-ban-ying-ping-shu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>爬取豆瓣影评数据步骤：<br>1、获取网页请求<br>2、解析获取的网页<br>3、提速数据<br>4、保存文件</p><h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><pre><code class="python"># 1、导入需要的库import urllib.requestfrom bs4 import BeautifulSoup# 随机数的库import random# 时间库import time# 表格库import csv# 2、分多个浏览器访问豆瓣网，防止访问多页时被拒绝# 每个浏览器在请求数据的时候，请求头是不一样# 计算机命名规则：驼峰命名法# url：传值过来的访问地址def getRequest(url):    # 谷歌浏览器    header1 = {        "Host":"movie.douban.com",        "User-Agent":"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36"    }    # 火狐浏览器    header2 = {        "Host": "movie.douban.com",        "User-Agent": "Mozilla/5.0 (Windows NT 6.1; rv:73.0) Gecko/20100101 Firefox/73.0"    }    # 将浏览器装入列表里    list = [header1,header2]    # 随机取一个请求头  len(list)-1：列表长度-1    index = random.randint(0,len(list)-1)    # 随机用一个请求头，开始访问地址    req = urllib.request.Request(url=url,headers=list[index])    # 返回结果    return req# 封装函数，爬取数据def getData(url,commentAll):    # 获取处理后的请求    req = getRequest(url)    # 打开网址    html = urllib.request.urlopen(req)    # 读取数据(data得到所有数据)    data = html.read()    # 输出爬取到的所有数据，进制形式显示    # print(data)    # 定义soup对象，解析网页    soup = BeautifulSoup(data,"html.parser")    # 找到装有所有评论的id名为comments的div    # ["数据"]  数组里只有一个元素----数据    comments = soup.select("#comments")[0]    # print(comments)    # 读取到每一条评论，div的class名为comment-item    items = comments.select(".comment-item")    # print(items)    # 循环遍历每一条评论    for i in items:        # 找到装着用户名和星级的span标签，class名为comment-info        info = i.select(".comment-info")[0]        # print(info)        # 读出用户名的a标签里面的字符串用户名 [&lt;a&gt;&lt;/a&gt;]        # author = info.select("a")[0].string  数据在列表里        author = info.find("a").string        # print(author)        # 取星级，找到装着星级的span标签，读取title值        # ["看过"，星级，时间]        star = info.select("span")[1]["title"]        # print(star)        # 取评论，找到class名为short的p标签        short = i.select(".short")[0].string        # print(short)        # 将 用户名、星级、评论 装入在字典里面        talk = {"author":author,"star":star,"short":short}        # print(talk)        # 将字典类型的数据，加到列表里面        commentAll.append(talk)    # 返回整个列表    return commentAll# 封装函数，把数据装入表格中def writeInto(commentAll):    # 打开表格  as从命名 file    # 参数1：表格名称    # 参数2："a+"追加模式  "w"写入模式   "r"读取模式    # w：writer   r：read  a：append    # wb二进制，不带b就是文本    # 参数3：数据格式为utf-8    # 参数4：newline 新行，空行    with open("douban.csv","a+",encoding="utf-8",newline="") as file:        # 向表格写入数据        writer = csv.writer(file)        # 数据在commentAll列表，循环遍历列表，读取数据        for i in commentAll:            # 读取每一个字段  用户名、星级、评论            info = [i["author"],i["star"],i["short"]]            # 把数据写入表格            writer.writerow(info)        # 关闭表格        file.close()# 函数的入口# 直接输入main，有提示if __name__ == '__main__':    # 初始化一个空列表,将得到的所有数据    commentAll = []    # range()产生序列 0.1.2,爬取3页    for i in range(0,3):        # 爬取的网页地址        # limit=20 每一页读取20条数据        # start = 80  从第几条读取数据 20-39  40-59  60-79 80-99        url = "https://movie.douban.com/subject/25931446/comments?start=%d&amp;limit=20&amp;sort=new_score&amp;status=P"%(i*20)        # 调用函数，爬取数据        getData(url,commentAll)        # 每爬取一个页面数据，休息10秒，防止被封号        time.sleep(10)    # 调用函数，爬取完数据，装入表格    writeInto(commentAll)    # 将表格用 记事本 打开，另存为ANSI格式    # 如果你要操作数据，还要转回utf-8</code></pre><h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><p><img src="https://img-blog.csdnimg.cn/20200226190737397.png" alt="效果图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开发工具 idea】值得推荐的15款idea插件</title>
      <link href="/2020/04/05/kai-fa-gong-ju-idea-zhi-de-tui-jian-de-15-kuan-idea-cha-jian/"/>
      <url>/2020/04/05/kai-fa-gong-ju-idea-zhi-de-tui-jian-de-15-kuan-idea-cha-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p>对于一个猿来说，工欲善其事，必先利其器，一个好的开发工具就是程序员的左膀右臂，idea作为大部分java猿的开发工具，无疑是最好用的ide了。IntelliJ在业界被公认为最好的java开发工具，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。</p><p>而idea的插件更是能够给我们日常开发带来很多便利，下面就是我想推荐给大家的几个插件。<br><img src="https://img-blog.csdnimg.cn/20200317160711417.png" alt="plugina"></p><h1 id="壹：插件安装"><a href="#壹：插件安装" class="headerlink" title="壹：插件安装"></a>壹：插件安装</h1><p>idea的插件安装可以分为两种，第一种就是直接在idea里面下载、安装。第二种可以将压缩包先下载好，然后再在idea中导入，即可完成安装。下面所有的安装都可以通过这两种安装方式来安装。<br>注：插件安装重启idea生效</p><p><a href="https://plugins.jetbrains.com/" target="_blank" rel="noopener">jetbrains插件官网</a></p><h2 id="一：在线安装"><a href="#一：在线安装" class="headerlink" title="一：在线安装"></a>一：在线安装</h2><p>file -&gt; setting -&gt; plugins -&gt; search -&gt; install -&gt; restart idea<br><img src="https://img-blog.csdnimg.cn/20200317155508764.png" alt="在线安装"></p><h2 id="二：本地安装"><a href="#二：本地安装" class="headerlink" title="二：本地安装"></a>二：本地安装</h2><p>file -&gt; setting -&gt; plugins -&gt; install plugins from disk-&gt; 选择压缩包 -&gt; ok -&gt; restart idea<br><img src="https://img-blog.csdnimg.cn/20200317160537509.png" alt="本地安装"></p><h1 id="贰：插件："><a href="#贰：插件：" class="headerlink" title="贰：插件："></a>贰：插件：</h1><h2 id="一：炫酷"><a href="#一：炫酷" class="headerlink" title="一：炫酷"></a>一：炫酷</h2><h3 id="15、Activate-power-mode或者Intellij-power-mode-II"><a href="#15、Activate-power-mode或者Intellij-power-mode-II" class="headerlink" title="15、Activate-power-mode或者Intellij_power_mode_II"></a>15、Activate-power-mode或者Intellij_power_mode_II</h3><p>你试过在敲代码的时候像打游戏一样燃吗，当你装上这个插件的时候，每敲下一串代码，整个屏幕都在颤抖。<br>当然，这样的插件玩玩就好，在真实的开发环境要求的是速度。</p><h3 id="14、background-image-plus"><a href="#14、background-image-plus" class="headerlink" title="14、background image plus"></a>14、background image plus</h3><p>你的ide是不是除了黑色就是白色，顶多就带一点灰，而对于二次元的小伙伴，如果能在敲代码的时候也能欣赏自己的老婆，是不是很赞。该插件支持给你的idea添加背景图片。<br>设置：view-&gt;set background image<br><img src="https://img-blog.csdnimg.cn/20200317145510935.png" alt="background image plus"></p><h3 id="13、rainbow-brackets"><a href="#13、rainbow-brackets" class="headerlink" title="13、rainbow brackets"></a>13、rainbow brackets</h3><p>我们常常在开发中是否遇到括号太多，而找不到相应的括号，而尤其在删除代码的时候，及其困扰，是不是？而rainbow brackets恰好能解决这些问题。<br>这个插件可以实现配对括号相同颜色，并且实现选中区域代码高亮的功能。对增强写代码的有趣性和排错等都有一些帮助。<br>在这里插入图片描述<img src="https://img-blog.csdnimg.cn/20200317145927430.png" alt="rainbow brackets"></p><h2 id="二：实用"><a href="#二：实用" class="headerlink" title="二：实用"></a>二：实用</h2><h3 id="12、translation"><a href="#12、translation" class="headerlink" title="12、translation"></a>12、translation</h3><p>英语不好的人的福音来了，你是不是经常在看别人的代码，遇到很多英语单词不认识，而从idea里面复制不认识的单词，再去查就很麻烦对不对，这款插件你就能直接在idea里面实现单词或者语句的翻译。<br>使用：选中你要查询的单词或语句，右键，选择translate<br><img src="https://img-blog.csdnimg.cn/20200317151341571.png" alt="translate"></p><h3 id="11、statistic"><a href="#11、statistic" class="headerlink" title="11、statistic"></a>11、statistic</h3><p>显示项目统计信息。该插件显示按扩展名排序的文件以及大小，行数LOC等。用户可以使用“选择时刷新”按钮选择（项目/模块/包/文件）作用域。（此插件需要Java 1.8）<br>使用：点击控制台下方statistic按钮，再点击刷新按钮<br><img src="https://img-blog.csdnimg.cn/2020031715163414.png" alt="statistic"></p><h3 id="10、RestfulToolkit"><a href="#10、RestfulToolkit" class="headerlink" title="10、RestfulToolkit"></a>10、RestfulToolkit</h3><p>RESTful服务开发的工具包。</p><ul><li>1.一步一步导航到服务声明。（使用：Ctrl（Command）+ \或Ctrl + Alt + N）</li><li>2.显示RESTful服务结构。</li><li>3.一个简单的http请求工具。</li><li>4.在请求方法，生成和复制查询参数，生成和复制URL等处添加一些有用的功能。</li><li>5，其他功能：转换为JSON; 转换为Java类，格式化json数据（Windows：Ctrl + Enter； Mac：Command + Enter）。</li></ul><p>支持Spring框架（Spring MVC / Spring Boot 1.x，2.x）<br>支持JAX-RS<br>支持Java和Kotlin语言<br><img src="https://img-blog.csdnimg.cn/20200317152033418.png" alt="RestfulToolkit"></p><h3 id="9、lombok"><a href="#9、lombok" class="headerlink" title="9、lombok"></a>9、lombok</h3><p>写实体类时，我们常常需要写他的set、get、构造方法等，lombok可以使代码现在变得非常容易，只需突出显示一个块并在IDE中键入注释即可。减轻代码审查的痛苦并提高代码质量。<br>注意：它需要在项目中引入依赖（pom.xml），在使用中只要加入@Data注解就可以</p><pre><code class="xml">&lt;!--        引入lombok--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200317152504198.png" alt="lombok"></p><h3 id="8、alibaba-Java-coding-guidelines"><a href="#8、alibaba-Java-coding-guidelines" class="headerlink" title="8、alibaba Java coding guidelines"></a>8、alibaba Java coding guidelines</h3><p>我们在刚写代码时，自己书写的代码会不规范，尤其在团队合作中，会时整个项目变得非常乱，而该插件与下面的sonarLint都能解决你的问题。会在你写代码的时候提醒你，从而使你的代码变得规范。<br><img src="https://img-blog.csdnimg.cn/20200317153244625.png" alt="alibaba Java coding guidelines"></p><h3 id="7、sonarLint"><a href="#7、sonarLint" class="headerlink" title="7、sonarLint"></a>7、sonarLint</h3><p>SonarLint是一个IDE扩展，可帮助您在编写代码时检测和修复质量问题。像拼写检查器一样，SonarLint可以使缺陷变形，因此可以在提交代码之前将其修复。您可以直接从IntelliJ IDEA插件存储库中获取它，然后它将在您编写代码（Java，Kotlin，Ruby，JavaScript，PHP和Python）时检测到新的错误和质量问题。</p><p>如果在SonarQube或SonarCloud上分析了您的项目，SonarLint可以连接到服务器以检索该项目的适当质量配置文件和设置。运行SonarLint需要Java 8。</p><p>使用：选择你要检测的文件，然后点击下方sonarLint，再点击运行按钮。<br><img src="https://img-blog.csdnimg.cn/20200317153007803.png" alt="sonarLint"></p><h3 id="6、key-promoter-X"><a href="#6、key-promoter-X" class="headerlink" title="6、key promoter X"></a>6、key promoter X</h3><p>一个用于学习IntelliJ IDEA快捷方式的插件。<br>Key Promoter X可帮助您在工作时学习基本的快捷方式。当您在IDE内的按钮上使用鼠标时，Key Promoter X会显示您应该使用的键盘快捷键。这提供了一种简单的方法来学习如何用键盘按键代替繁琐的鼠标工作，并有助于过渡到更快的无鼠标开发。当前，它支持工具栏按钮，菜单按钮，工具窗口及其中的操作。</p><p>Key Promoter X工具窗口显示了您最常使用的鼠标操作的命中列表，并直接为您提供了可以使用的快捷方式。对于没有快捷方式的按钮，Key Promoter X会提示您直接创建一个。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vZmlsZXMvOTc5Mi9zY3JlZW5zaG90XzE3MTA1LnBuZw?x-oss-process=image/format,png" alt="Key Promoter X"></p><h3 id="5、Mybatis-log-plugin"><a href="#5、Mybatis-log-plugin" class="headerlink" title="5、Mybatis-log-plugin"></a>5、Mybatis-log-plugin</h3><p>MyBatis日志插件<br>把mybatis输出的sql日志还原成完整的sql语句。<br>将日志输出的sql语句中的问号？替换成真正的参数值。<br>通过“工具- &gt; MyBatis的日志插件”。菜单或快捷键“Ctrl + Shift + ALT + O”的启用。点击窗口左边的“过滤器”按钮，可以过滤不想要输出的SQL语句<br>点击窗口左边的“格式SQL”的按钮，可以格式化输出的SQL语句。<br>选中控制台的SQL日志，右击“从选择还原SQL”菜单可以还原SQL语句。<br>前提条件：输出的SQL日志必须包含“准备”和“参数”。才能正常解析<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vZmlsZXMvMTAwNjUvc2NyZWVuc2hvdF8xNzM2Ny5wbmc?x-oss-process=image/format,png" alt="Mybatis-log-plugin"></p><h3 id="4、Free-idea-mybatis"><a href="#4、Free-idea-mybatis" class="headerlink" title="4、Free-idea-mybatis"></a>4、Free-idea-mybatis</h3><p>free-idea-mybatis是用于支持mybatis的想法的交换插件，这是主要功能：</p><ul><li>生成映射器xml文件</li><li>从代码导航到映射器mapper，然后从映射器mapper导航回代码</li><li>自动代码和错误提示</li><li>支持mybatis生成器GUI<h3 id="3、CodeGlance"><a href="#3、CodeGlance" class="headerlink" title="3、CodeGlance"></a>3、CodeGlance</h3>将类似于Sublime中的代码的微型地图嵌入到编辑器窗格中。使用您自定义的颜色突出显示语法，可同时使用浅色和深色主题。<br><img src="https://img-blog.csdnimg.cn/20200317154043841.png" alt="CodeGlance"><h3 id="2、MyBatisCodeHelperPro"><a href="#2、MyBatisCodeHelperPro" class="headerlink" title="2、MyBatisCodeHelperPro"></a>2、MyBatisCodeHelperPro</h3>他的功能非常强大，然而他并不免费（29软妹币半年），下面有传送门，土豪请随意。<br>主要特征：</li><li>通过Intellij数据库表生成mybatis原始代码或添加数据库连接</li><li>基于mybatis接口方法名称（例如spring data jpa）生成mybatis sql，使用此方法，无需使用if test即可为非连接查询支持generate语句编写大多数sql</li><li>当您添加或删除列时，数据库generate crud可能会生成多次，插件将自动合并代码</li><li>完整的mybatis sql自动完成功能，在xml中识别mybatis标记，例如修剪集包含ect的地方，在这些标记后提供sql完成</li><li>从mybatis dao界面跳转到mapper xml</li></ul><p>介绍：<a href="https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro</a><br>传送门：<a href="https://zhile.io/2019/04/23/mybatis-code-helper-pro-crack.html" target="_blank" rel="noopener">https://zhile.io/2019/04/23/mybatis-code-helper-pro-crack.html</a></p><h3 id="1、aiXcode"><a href="#1、aiXcode" class="headerlink" title="1、aiXcode"></a>1、aiXcode</h3><p>AiXcoder是使用最新AI技术的代码建议生成器。开发者的模型在超过1 TB的开源代码上进行了训练，并通过您自己的计算机提供服务。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlLmFpeGNvZGVyLmNvbS9pbWcvZGVtby9uL2phdmExLmdpZg" alt="aiXcode"></p><h1 id="叁：作者有话"><a href="#叁：作者有话" class="headerlink" title="叁：作者有话"></a>叁：作者有话</h1><p>希望我的博文能够帮助到你，能够让你在开发过程中能够更加的便捷，最后，希望正在看这篇博文的你早日成为大佬，然后再来带带小菜鸡的我鸭。<br><img src="https://img-blog.csdnimg.cn/20200405094243147.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【springmvc thymeleaf】springmvc整合thymeleaf</title>
      <link href="/2020/04/05/springmvc-thymeleaf-springmvc-zheng-he-thymeleaf/"/>
      <url>/2020/04/05/springmvc-thymeleaf-springmvc-zheng-he-thymeleaf/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Thymeleaf提供了一组Spring集成，使您可以将其用作Spring MVC应用程序中JSP的全功能替代品。</p><p>这些集成将使您能够：</p><ul><li>@Controller像使用JSP一样，将Spring MVC 对象中的映射方法转发到Thymeleaf管理的模板。</li><li>在模板中使用Spring表达式语言（Spring EL）代替OGNL。</li><li>在与表单支持Bean和结果绑定完全集成的模板中创建表单，包括使用属性编辑器，转换服务和验证错误处理。</li><li>显示Spring管理的消息文件中的国际化消息（通过常规MessageSource对象）。</li><li>使用Spring自己的资源解析机制解析您的模板。</li></ul><p>thymeleaf自己也做了spring的集成，所以我们并不需要做太多的配置，就可以达到我们想要的结果。thymeleaf提供了两种集成方法：①、注解配置，也就是java代码，②、xml文件配配置，本文主要介绍第二种xml配置。</p><h2 id="你能get到的知识点："><a href="#你能get到的知识点：" class="headerlink" title="你能get到的知识点："></a>你能get到的知识点：</h2><p>1、springmvc整合thymeleaf<br>2、spring提供的三种model的使用<br>3、解决html前端thymeleaf不生效问题（见问题1）<br>4、解决html前端显示乱码问题（见问题2）</p><h1 id="springmvc整合thymeleaf"><a href="#springmvc整合thymeleaf" class="headerlink" title="springmvc整合thymeleaf"></a>springmvc整合thymeleaf</h1><h2 id="一：加入依赖"><a href="#一：加入依赖" class="headerlink" title="一：加入依赖"></a>一：加入依赖</h2><p>在springmvc里面，除了要加入<code>thymeleaf</code>的主依赖之外，还需要<code>thymeleaf-spring4</code>，否则会报<code>org.thymeleaf.spring4.view.ThymeleafViewResolver</code>，找不到thymeleaf解析器，所以<code>thymeleaf-spring4</code>也是必不可少的。</p><blockquote><p>Thymeleaf具有针对Spring Framework 3.x和4.x的集成，由两个独立的库分别称为thymeleaf-spring3和提供thymeleaf-spring4。这些库打包在单独的.jar文件（thymeleaf-spring3-{version}.jar和thymeleaf-spring4-{version}.jar）中，需要添加到类路径中，以便在应用程序中使用Thymeleaf的Spring集成<br>。</p></blockquote><pre><code class="xml">&lt;!--        thymeleaf--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-spring4&lt;/artifactId&gt;    &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt;    &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="二：设置thymeleaf解析器"><a href="#二：设置thymeleaf解析器" class="headerlink" title="二：设置thymeleaf解析器"></a>二：设置thymeleaf解析器</h2><p>在springmvc配置文件中配置thymeleaf解析器，官方文档中Thymeleaf提供了上述两个接口的实现：</p><pre><code>org.thymeleaf.spring4.view.ThymeleafVieworg.thymeleaf.spring4.view.ThymeleafViewResolver</code></pre><p>不过现在都已经被<code>org.thymeleaf.spring4.view.ThymeleafViewResolver</code>所代替，至于以上配置是否还能够生效，就要靠你来试试了。</p><pre><code class="xml"> &lt;!-- thymeleaf 模板解析器 --&gt;    &lt;bean id="templateResolver" class="org.thymeleaf.spring4.templateresolver.SpringResourceTemplateResolver"&gt;        &lt;property name="prefix" value="/" /&gt;        &lt;property name="suffix" value=".html" /&gt;        &lt;property name="templateMode" value="HTML" /&gt;        &lt;property name="cacheable" value="false" /&gt;        &lt;property name="characterEncoding" value="UTF-8"/&gt;    &lt;/bean&gt;    &lt;bean id="templateEngine" class="org.thymeleaf.spring4.SpringTemplateEngine"&gt;        &lt;property name="templateResolver" ref="templateResolver" /&gt;    &lt;/bean&gt;    &lt;!--    视图解析器--&gt;    &lt;bean id="viewResolver" class="org.thymeleaf.spring4.view.ThymeleafViewResolver"&gt;        &lt;property name="templateEngine" ref="templateEngine" /&gt;        &lt;property name="characterEncoding" value="UTF-8"/&gt;    &lt;/bean&gt;</code></pre><p>ViewResolvers是负责获取特定操作和语言环境的View对象的对象。通常，控制器要求ViewResolvers转发到具有特定名称的视图（由controller方法返回的String），然后应用程序中的所有视图解析器将按有序链执行，直到其中一个能够解析该视图为止。如果返回了View对象，并且将控件传递给该对象以呈现HTML。</p><p><strong>注：值得注意的是</strong>，如果自己设置了spring的视图解析器，需要将其注释掉，否则thymeleaf解析器可能不会生效，我就是因为这个调试了好久，最后才发现这个问题。</p><pre><code class="xml">    &lt;!--    配置视图解析器 prefix：前缀， suffix：后缀   使用thymeleaf需要将其注释掉--&gt;    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;        &lt;property name="prefix" value="/"/&gt;        &lt;property name="suffix" value=".html"/&gt;    &lt;/bean&gt;</code></pre><h2 id="三：编写控制器"><a href="#三：编写控制器" class="headerlink" title="三：编写控制器"></a>三：编写控制器</h2><p>需要从控制层传数据到视图时，我们就会使用model，常用的三种model就是：<strong>Model、ModelMap、ModelAndView</strong>。使用这三种model时，spring框架自动创建实例并作为controller的入参，用户无需自己创建</p><h3 id="1、使用Model"><a href="#1、使用Model" class="headerlink" title="1、使用Model"></a>1、使用Model</h3><pre><code class="java">    /**     * 在Model里存入一个用户信息     * @return hello页面     */    @GetMapping("returnModelAndView")    public String returnModelAndView(Model model){        model.addAttribute("userInfo",new UserInfo("lomtom","123",new Address("湖南","邵阳")));        return "hello";    }</code></pre><p>Model是一个接口，<br>Model源码：</p><pre><code class="java">public interface Model {    Model addAttribute(String var1, Object var2);    Model addAttribute(Object var1);    Model addAllAttributes(Collection&lt;?&gt; var1);    Model addAllAttributes(Map&lt;String, ?&gt; var1);    Model mergeAttributes(Map&lt;String, ?&gt; var1);    boolean containsAttribute(String var1);    Map&lt;String, Object&gt; asMap();}</code></pre><h3 id="2、使用ModelMap"><a href="#2、使用ModelMap" class="headerlink" title="2、使用ModelMap"></a>2、使用ModelMap</h3><p>ModelMap继承LinkedHashMap<br>ModelMap源码：</p><pre><code class="java">public class ModelMap extends LinkedHashMap&lt;String, Object&gt; {    public ModelMap() {    }    public ModelMap(String attributeName, Object attributeValue) {        this.addAttribute(attributeName, attributeValue);    }    public ModelMap(Object attributeValue) {        this.addAttribute(attributeValue);    }    public ModelMap addAttribute(String attributeName, Object attributeValue) {        Assert.notNull(attributeName, "Model attribute name must not be null");        this.put(attributeName, attributeValue);        return this;    }    public ModelMap addAttribute(Object attributeValue) {        Assert.notNull(attributeValue, "Model object must not be null");        return attributeValue instanceof Collection &amp;&amp; ((Collection)attributeValue).isEmpty() ? this : this.addAttribute(Conventions.getVariableName(attributeValue), attributeValue);    }    public ModelMap addAllAttributes(Collection&lt;?&gt; attributeValues) {        if (attributeValues != null) {            Iterator var2 = attributeValues.iterator();            while(var2.hasNext()) {                Object attributeValue = var2.next();                this.addAttribute(attributeValue);            }        }        return this;    }    public ModelMap addAllAttributes(Map&lt;String, ?&gt; attributes) {        if (attributes != null) {            this.putAll(attributes);        }        return this;    }    public ModelMap mergeAttributes(Map&lt;String, ?&gt; attributes) {        if (attributes != null) {            Iterator var2 = attributes.entrySet().iterator();            while(var2.hasNext()) {                Entry&lt;String, ?&gt; entry = (Entry)var2.next();                String key = (String)entry.getKey();                if (!this.containsKey(key)) {                    this.put(key, entry.getValue());                }            }        }        return this;    }    public boolean containsAttribute(String attributeName) {        return this.containsKey(attributeName);    }}</code></pre><h3 id="3、使用ModelAndView"><a href="#3、使用ModelAndView" class="headerlink" title="3、使用ModelAndView"></a>3、使用ModelAndView</h3><pre><code class="java">    /**     * 在ModelAndView里存入一个用户信息     * @return ModelAndView      */    @GetMapping("returnModelAndView")    public ModelAndView returnModelAndView(ModelAndView modelAndView){        modelAndView.setViewName("hello");        modelAndView.addObject("userInfo",new UserInfo("lomtom","123",new Address("湖南","邵阳")));        return modelAndView;    }</code></pre><p>ModelAndView顾名思义就是模型和试图的结合。<br>ModelAndView源码：</p><pre><code class="java">public class ModelAndView {    private Object view;    private ModelMap model;    private HttpStatus status;    private boolean cleared = false;    ......}</code></pre><h2 id="四：编写html"><a href="#四：编写html" class="headerlink" title="四：编写html"></a>四：编写html</h2><p>首先，写一个链接，请求<code>returnModelAndView</code>请求。</p><pre><code class="html">&lt;a href="returnModelAndView"&gt;ModelAndView&lt;/a&gt;</code></pre><p>然后，写hello.html页面用于验证</p><pre><code class="html">&lt;h2&gt;你好啊，你成功了&lt;/h2&gt;&lt;p th:text="${userInfo.userName}+'来自'+${userInfo.address.province}+${userInfo.address.city}"&gt;&lt;/p&gt;</code></pre><h2 id="五：结果"><a href="#五：结果" class="headerlink" title="五：结果"></a>五：结果</h2><p><img src="https://img-blog.csdnimg.cn/20200401143955232.png" alt=""></p><h2 id="六：记录我遇到的问题"><a href="#六：记录我遇到的问题" class="headerlink" title="六：记录我遇到的问题"></a>六：记录我遇到的问题</h2><p><strong>问题1</strong>：配置好一切后，thymeleaf无法解析，所有关于thymeleaf的显示都无法生效。<br><strong>解决</strong>：由于我配置了spring的视图解析，所以导致thymeleaf的试图解析无法生效，所以去掉spring的视图解析。</p><blockquote><p>thmelaf介绍Springmvc的视图解析：<br>快速浏览其属性足以了解其配置方式：</p><ul><li>viewClass建立View实例的类。对于JSP解析器，这是必需的，但是当我们与Thymeleaf合作时，根本不需要。</li><li>prefix与suffixThymeleaf的TemplateResolver对象中相同名称的属性的工作方式相似。</li><li>order 确定在链中查询ViewResolver的顺序。</li><li>viewNames 允许使用此ViewResolver解析视图名称（带通配符）。</li></ul></blockquote><p><strong>问题2</strong>：前端显示乱码，具体表现为后台传入的不乱码，但是html中原本存在的乱码。<br><strong>解决</strong>：在试图解析器和模板解析器中加入参数：<code>&lt;property name="characterEncoding" value="UTF-8"/&gt;</code></p><h1 id="作者有话"><a href="#作者有话" class="headerlink" title="作者有话"></a>作者有话</h1><p>我写的可能并不怎么详细，详细配置请查看thymeleaf官方介绍：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html#views-and-view-resolvers-in-spring-mvc" target="_blank" rel="noopener">传送门</a>，到最后，看都看完了，如果对你有帮助，请点个赞吧。<br><img src="https://img-blog.csdnimg.cn/20200405094243147.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
            <tag> thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【spring springmvc】这里有你想要的SpringMVC的REST风格的四种请求方式</title>
      <link href="/2020/03/29/spring-springmvc-zhe-li-you-ni-xiang-yao-de-springmvc-de-rest-feng-ge-de-si-chong-qing-qiu-fang-shi/"/>
      <url>/2020/03/29/spring-springmvc-zhe-li-you-ni-xiang-yao-de-springmvc-de-rest-feng-ge-de-si-chong-qing-qiu-fang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前的文章<a href="https://blog.csdn.net/qq_41929184/article/details/104997012" target="_blank" rel="noopener">springmvc使用注解声明控制器与请求映射</a>有简单提到过控制器与请求映射，这一次就详细讲解一下<code>SpringMVC</code>的<code>REST</code>风格的四种请求方式及其使用方法。</p><h2 id="你能get的知识点"><a href="#你能get的知识点" class="headerlink" title="你能get的知识点"></a>你能get的知识点</h2><p>1、什么是Rest风格？<br>2、基于<code>springmvc</code>实现REST风格的四种请求方式<br>3、post请求转换为<code>delete</code>与<code>put</code>请求<br>4、解决请求乱码问题<br>5、<code>RequestMapping</code>注解的属性</p><h1 id="壹：rest风格"><a href="#壹：rest风格" class="headerlink" title="壹：rest风格"></a>壹：rest风格</h1><h2 id="一：什么是Rest风格？"><a href="#一：什么是Rest风格？" class="headerlink" title="一：什么是Rest风格？"></a>一：什么是Rest风格？</h2><p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。</p><p>简单来说：使用URL定位资源，用HTTP动词（例如GET,POST,DELETE,DETC等）描述操作。</p><h2 id="二：REST风格的四种请求方式"><a href="#二：REST风格的四种请求方式" class="headerlink" title="二：REST风格的四种请求方式"></a>二：REST风格的四种请求方式</h2><table><thead><tr><th>请求</th><th>说明</th><th>用于</th><th>例子</th><th>例子说明</th></tr></thead><tbody><tr><td>@GetMapping</td><td>匹配GET方式的请求；</td><td>一般用于读取数据</td><td>/user/1</td><td>获取一号用户信息</td></tr><tr><td>@PostMapping</td><td>匹配POST方式的请求；</td><td>一般用于新增数据</td><td>/user/1</td><td>新增一号用户</td></tr><tr><td>@PutMapping</td><td>匹配PUT方式的请求；</td><td>一般用于更新数据</td><td>/user/1</td><td>修改一号用户</td></tr><tr><td>@DeleteMapping</td><td>匹配DELETE方式的请求；</td><td>一般用于删除数据</td><td>/user/1</td><td>删除一号用户</td></tr></tbody></table><p>也就是说，我们不再使用<code>/user/getuser?user=1</code>、<code>/user/deleteuser?user=1</code>等来区分使用者的行为操作，而是使用不同的请求方式来描述行为。</p><h1 id="贰：基于springmvc实现REST风格的四种请求方式"><a href="#贰：基于springmvc实现REST风格的四种请求方式" class="headerlink" title="贰：基于springmvc实现REST风格的四种请求方式"></a>贰：基于<code>springmvc</code>实现REST风格的四种请求方式</h1><p>Spring框架的4.3版本后，引入了新的组合注解，来帮助简化常用的<code>HTTP</code>方法的映射，并更好的表达被注解方法的语义。</p><pre><code>@GetMapping = @requestMapping(method = RequestMethod.GET)。@PostMapping = @requestMapping(method = RequestMethod.POST)。@DeleteMapping = @requestMapping(method = RequestMethod.DELETE)。@PutMapping = @requestMapping(method = RequestMethod.PuT)。</code></pre><h2 id="一：-GetMapping请求"><a href="#一：-GetMapping请求" class="headerlink" title="一：@GetMapping请求"></a>一：@GetMapping请求</h2><p> 以<code>@GetMapping</code>为例，该组合注解是<code>@RequestMapping(method = RequestMethod.GET)</code>的缩写，它会将HTTP GET请求映射到特定的处理方法上。 </p><p><code>RequestMapping</code>后所有属性都是可选的，但其默认属性是<code>value</code>。当<code>value</code>是其唯一属性时，可以省略属性名。</p><pre><code class="java">@RequestMapping(value = "/rest",method = RequestMethod.GET)public String restGet(){    System.out.println("Get请求，hello.....");    return "hello";}</code></pre><p> <code>@GetMapping</code>是一个组合注解，是<code>@RequestMapping(method = RequestMethod.GET)</code>的缩写。<br> 所以我们可以将以上代码简单的写成：</p><pre><code class="java">@GetMapping("/rest")public String restGet(){    System.out.println("Get请求，hello.....");    return "hello";}</code></pre><h2 id="二：-PostMapping请求"><a href="#二：-PostMapping请求" class="headerlink" title="二：@PostMapping请求"></a>二：@PostMapping请求</h2><pre><code class="java">    @PostMapping("/rest")    public String restPost(){        System.out.println("Post请求，hello.....");        return "hello";    }</code></pre><h2 id="三：-DeleteMapping请求"><a href="#三：-DeleteMapping请求" class="headerlink" title="三：@DeleteMapping请求"></a>三：@DeleteMapping请求</h2><pre><code class="java">    @DeleteMapping("/rest")    public String restDelete(){        System.out.println("Delete请求，hello.....");        return "redirect:rest";    }</code></pre><h2 id="四：-PutMapping请求"><a href="#四：-PutMapping请求" class="headerlink" title="四：@PutMapping请求"></a>四：@PutMapping请求</h2><pre><code class="java">    @PutMapping("/rest")    public String restPut(){        System.out.println("Put请求，hello.....");        return "redirect:rest";    }</code></pre><h1 id="叁：问题"><a href="#叁：问题" class="headerlink" title="叁：问题"></a>叁：问题</h1><h2 id="一：post请求转换为delete与put请求"><a href="#一：post请求转换为delete与put请求" class="headerlink" title="一：post请求转换为delete与put请求"></a>一：post请求转换为delete与put请求</h2><p>由于form表单只支持GET和POST请求，而不支持DELETE和PUT等请求方式，所以我们实现delete和put请求往往会报错找不到方法。</p><p>Spring提供了一个过滤器<code>HiddenHttpMethodFilter</code>，可以将DELETE和PUT请求转换为标准的HTTP方式，即能将POST请求转为DELETE或PUT请求。 </p><p><strong>具体实现</strong>：在web.xml文件中配置过滤器HiddenHttpMethodFilter</p><pre><code class="xml">&lt;!--使用Rest风格的URI,将页面普通的post请求转为delete或者put请求--&gt;  &lt;filter&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre><p><strong>注意</strong>：delete和put请求最好使用Redirect(重定向)，不然会报404错误。</p><h2 id="二：解决请求乱码问题"><a href="#二：解决请求乱码问题" class="headerlink" title="二：解决请求乱码问题"></a>二：解决请求乱码问题</h2><pre><code class="xml"> &lt;!--  解决乱码问题--&gt;  &lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;forceEncoding&lt;/param-name&gt;      &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre><p><strong>注意</strong>：编码的过滤器应该放在所有的过滤器前，否则不生效</p><h1 id="肆：RequestMapping注解的属性"><a href="#肆：RequestMapping注解的属性" class="headerlink" title="肆：RequestMapping注解的属性"></a>肆：RequestMapping注解的属性</h1><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>可选属性，用于为映射地址指定别名。</td></tr><tr><td>value</td><td>String[]</td><td>可选属性，同时也是默认属性，用于映射一-个请求和一种方法，可以标注在一-个方法或一个类上。</td></tr><tr><td>method</td><td>RequestMethod[]</td><td>可选属性，用于指定该方法用于处理哪种类型的请求方式，其请求方式包括GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE和TRACE例如method=RequestMethod.GET表示只支持GET请求，如果需要支持多个请求方式则需要通过{}写成数组的形式，并且多个请求方式之间是有英文逗号分隔。</td></tr><tr><td>params</td><td>String[]</td><td>可选属性，用于指定Request中必须包含某些参数的值，.才可以通过其标注的方法处理。</td></tr><tr><td>headers</td><td>String[]</td><td>可选属性,用于指定Request中必须包含某些指定的header的值，才可以通过其标注的方法处理。。</td></tr><tr><td>consumes</td><td>String[]</td><td>可选属性，用于指定处理请求的提交内容类型(Content-type)，比如application/json,text/html等。</td></tr><tr><td>produces</td><td>String[]</td><td>可选属性，用于指定返回的内容类型，返回的内容类型必,须是request请求头(Accept)中所包含的类型。</td></tr></tbody></table><blockquote><p>表中所有属性都是可选的，但其默认属性是value。当value是其唯一属性时， 可以省略属性名。<br>例如，下面两种标注的含义相同：<br>@RequestMapping(value=”/rest”)<br>@RequestMapping(“/rest”)</p></blockquote><h1 id="伍：测试"><a href="#伍：测试" class="headerlink" title="伍：测试"></a>伍：测试</h1><p>新建index.html文件，加入以下代码。新建hello.html，用于请求后的页面跳转。</p><pre><code class="html">&lt;h2&gt;各种请求&lt;/h2&gt;&lt;a href="rest"&gt;hello Get请求&lt;/a&gt;&lt;form action="rest" method="post"&gt;    &lt;button type="submit"&gt;hello Post请求&lt;/button&gt;&lt;/form&gt;&lt;form action="rest" method="post"&gt;    &lt;input type="hidden" name="_method" value="delete"&gt;    &lt;button type="submit"&gt;hello Delete请求&lt;/button&gt;&lt;/form&gt;&lt;form action="rest" method="post"&gt;    &lt;input type="hidden" name="_method" value="put"&gt;    &lt;button type="submit"&gt;hello put请求&lt;/button&gt;&lt;/form&gt;</code></pre><p>结果：<img src="https://img-blog.csdnimg.cn/20200329124302860.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开发工具 浏览器】细数那些优秀的谷歌浏览器插件</title>
      <link href="/2020/03/23/kai-fa-gong-ju-liu-lan-qi-xi-shu-na-xie-you-xiu-de-gu-ge-liu-lan-qi-cha-jian/"/>
      <url>/2020/03/23/kai-fa-gong-ju-liu-lan-qi-xi-shu-na-xie-you-xiu-de-gu-ge-liu-lan-qi-cha-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>相信所有人包括程序员都离不开浏览器，而作为猿来说，谷歌浏览器是我们必不可少的工具，开发调试，查找资料都离不开他，所以说浏览器也是一款开发工具也不为过。<br><img src="https://img-blog.csdnimg.cn/20200322142629494.png" alt=""><br>浏览器经过过多年的发展，诞生了无数浏览器拓展程序，也就是插件，因为插件，我们使用浏览器变得更加便捷、实用。接下来，我将为大家介绍几款优秀的浏览器插件。</p><h1 id="壹：插件安装"><a href="#壹：插件安装" class="headerlink" title="壹：插件安装"></a>壹：插件安装</h1><p>插件的安装分为两种，一种时从应用商店直接安装，还有一种就是下载，然后在安装到浏览器中。个人推荐第一种，因为官方的安全还快捷。</p><h2 id="一：应用商店安装"><a href="#一：应用商店安装" class="headerlink" title="一：应用商店安装"></a>一：应用商店安装</h2><p>进入商店，搜索相关插件，点击添加到chrome -&gt; 确认添加拓展程序，然后他就会下载好自动安装，简直简单到不能简单到再简单了。<br><img src="https://img-blog.csdnimg.cn/20200322162835163.png" alt=""></p><h2 id="二：本地安装"><a href="#二：本地安装" class="headerlink" title="二：本地安装"></a>二：本地安装</h2><p>第一步：首先在商店下载<br><img src="https://img-blog.csdnimg.cn/20200322161347990.png" alt=""><br>第二步：打开浏览器 -&gt; 更多工具 -&gt; 拓展程序 -&gt; 打开开发者模式 -&gt; 解压刚刚下载的插件 -&gt; 拖至浏览器空白处<br>注意是crx后缀的文件。<br><img src="https://img-blog.csdnimg.cn/20200322161939244.png" alt=""><br>第三步：确认添加拓展程序（不要问我为什么那一坨是黑的，不得不说CSDN审核真严格）<br><img src="https://img-blog.csdnimg.cn/20200323095157219.png" alt=""><br>注：有些浏览器可能会失败，因为谷歌做了限制，你可以下载浏览器开发板。</p><h2 id="三：下载地址"><a href="#三：下载地址" class="headerlink" title="三：下载地址"></a>三：下载地址</h2><blockquote><p>1、<a href="https://chrome.google.com/webstore/category/extensions?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">谷歌网上应用商店</a><br>2、<a href="https://www.extfans.com/" target="_blank" rel="noopener">Extfans</a><br> 3、<a href="http://www.cnplugins.com/" target="_blank" rel="noopener">chrome插件网</a></p></blockquote><h1 id="贰：插件"><a href="#贰：插件" class="headerlink" title="贰：插件"></a>贰：插件</h1><h2 id="8、google翻译"><a href="#8、google翻译" class="headerlink" title="8、google翻译"></a>8、google翻译</h2><p>此扩展将向浏览器工具栏添加按钮。每当您想翻译正在访问的页面时，请单击“翻译”图标。<br>扩展还会自动检测你所在页面的语言是否与你在Google Chrome界面上使用的语言不同。如果是，则会在页面顶部显示横幅。单击横幅中的“翻译”按钮，使页面上的所有文本以新语言显示。<br><img src="https://img-blog.csdnimg.cn/202003221547402.png" alt=""><br>当你在浏览网页时，突然遇到了某个陌生单词，复制再去查询是不是太麻烦，有了这款你就能立马在本页面查询。<img src="https://img-blog.csdnimg.cn/20200322155919692.png" alt=""></p><p>它不仅支持单个单词的查询还能翻译整个页面，尤其当我们在访问英文的网站，或者英文的开发文档时。当然谷歌也有内嵌了google翻译，但是偶尔他并不会弹出来。所以这个插件还是有必要的。<br><img src="https://img-blog.csdnimg.cn/20200322155329765.png" alt=""><br><img src="https://img-blog.csdnimg.cn/20200322155435242.png" alt=""></p><h2 id="7、dark-reader（夜猫子的福利）"><a href="#7、dark-reader（夜猫子的福利）" class="headerlink" title="7、dark reader（夜猫子的福利）"></a>7、dark reader（夜猫子的福利）</h2><p>这是一个护眼扩展程序，通过实时生成黑色主题，为每一个网站启用夜间模式。 Dark Reader反转明亮的颜色，使其网页内容具有高对比度并且在易于夜间阅读。<br><img src="https://img-blog.csdnimg.cn/20200322140100792.png" alt="dark reader"><br>黑色主题，适用于任何网站。关爱眼睛，就使用Dark Reader进行夜间和日间浏览。您可以调整亮度、对比度，应用棕褐色滤镜、黑暗模式，设置字体和忽略的网站列表。<br>Dark Reader无广告，也不会在任何地方发送用户的数据。它完全开源  <a href="https://github.com/darkreader/darkreader" target="_blank" rel="noopener">https://github.com/darkreader/darkreader</a> 。</p><p>笔者是经常要用浏览器的，无疑这款插件给我带来最的好处就是在熬夜时能让整个屏幕看起来不那么刺眼，并且在大部分网站，显示都是比较好的。<br><img src="https://img-blog.csdnimg.cn/20200322141054265.png" alt=""><br><img src="https://img-blog.csdnimg.cn/20200322141133502.png" alt=""><br>当然，如果你的浏览器内容是暗黑的，而浏览器外观却是白亮的，那肯定受不了，这时候你同样可以为你的浏览器在谷歌的网上应用商店里找一款暗黑的主题。最终我的是这样的。<br><img src="https://img-blog.csdnimg.cn/20200322141628778.png" alt=""><br><strong>值得注意的是，他可能会与同类插件有冲突，可能会导致显示有问题，我就遇到了百度显示不了内容，例如接下来我就要介绍的一款，这两款，你最好只选其中一款，作者推荐下一款，因为它可以安装暗黑的主题，还可以安装其他的，而这一款就只有这一个功能。</strong></p><h2 id="6、stylish和stylus"><a href="#6、stylish和stylus" class="headerlink" title="6、stylish和stylus"></a>6、stylish和stylus</h2><p>stylish曾经非常火爆，由于被知名软件工程师Robert Heaton爆出他会窃取用户的浏览历史，被谷歌下市，如今在谷歌应用商店里仍然搜得到，最终在介绍里留下了：</p><blockquote><p>我们非常重视您的隐私，所以我们必须保证您理解我们的隐私政策：为了向您提供Stylish服务，即显示与您访问的网页相关的和推荐的样式、以及安装次数，我们需要收集浏览数据。<br>详见我们的隐私政策：userstyles.org/login/policy。</p></blockquote><p>好吧，处于安全的考虑，大家可以不用sytylish，那么就有了他的替代品stylus。</p><p>Stylus 是一个调整网页外观的用户样式管理器。它可让您轻松地为许多热门网站网站安装主题和皮肤。<br><img src="https://img-blog.csdnimg.cn/2020032213553342.png" alt="stylus"><br>他里面可以下载很多网站的样式，基本上比较大的几个都有，当然，如果你有能力，你也可以自己写样式。样式下载:<a href="https://userstyles.org" target="_blank" rel="noopener">传送门</a><br>谷歌搜索安装插件前：<br><img src="https://img-blog.csdnimg.cn/20200322142950902.png#pic_center" alt=""><br>安装插件后：<br><img src="https://img-blog.csdnimg.cn/20200322143039458.png#pic_center" alt=""><br>百度pure安装前：<br><img src="https://img-blog.csdnimg.cn/20200322143435550.png" alt=""><br>安装后：<img src="https://img-blog.csdnimg.cn/20200322143512499.png" alt=""><br>安装前：<br><img src="https://img-blog.csdnimg.cn/20200322143610559.png" alt=""><br>安装后：<img src="https://img-blog.csdnimg.cn/20200322143624477.png" alt=""><br>相信大家区别已经看出来了，这里推荐两款主题：</p><ul><li>百度pure</li><li>全局思源黑体<h2 id="5、Fehelper"><a href="#5、Fehelper" class="headerlink" title="5、Fehelper"></a>5、Fehelper</h2>这时一款前端开发者工具，它具有相当强大的功能，是前端开发者必不可少的工具。<br><img src="https://img-blog.csdnimg.cn/20200322140446214.png" alt="fehelper"><br>以下为他的功能及介绍。<br><img src="https://img-blog.csdnimg.cn/20200322144212113.png#pic_center" alt="功能"><br>就拿我经常用的一个工具，需要请求数据，放回json数据，然后，他就会在浏览器显示美化，当然，你还可以复制一段json数据，他也能给你美化。<br><img src="https://img-blog.csdnimg.cn/20200322144901965.png" alt=""><br>自定义数据：<br><img src="https://img-blog.csdnimg.cn/20200322145127334.png" alt=""><h2 id="4、Adblock-Plus"><a href="#4、Adblock-Plus" class="headerlink" title="4、Adblock Plus"></a>4、Adblock Plus</h2>相信这个插件大家并不陌生，基本上大家都装着这个插件，它可以阻拦浏览器大部分广告，还支持自定义，享受没有恼人广告的网络世界。<br>Adblock Plus 是世界上最流行的浏览器扩展，世界各地有数百万用户在使用它。这是一个社区驱动的开源项目，有数百名志愿者为 Adblock Plus 的成功作出了贡献，以实现所有烦人的广告被自动阻挡。</li></ul><p>Adblock Plus for Google Chrome 会阻挡：</p><ul><li>横幅</li><li>YouTube 视频广告</li><li>Facebook 广告</li><li>弹出窗口</li><li>所有其他显眼的广告</li></ul><p><img src="https://img-blog.csdnimg.cn/20200322140537144.png" alt="Adblock Plus"></p><h2 id="3、广告终结者"><a href="#3、广告终结者" class="headerlink" title="3、广告终结者"></a>3、广告终结者</h2><blockquote><p> 广告终结者是一款参考各种广告过滤插件开发的功能全面的免费开源广告过滤工具。广告终结者让你不用再忍受网页上烦人的广告，不需要开通所谓的VIP，做任务，也不需要找各种功能不全的广告插件，广告终结者集成广告过滤的所有功能，是你唯一需要的必备广告过滤扩展。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200322150719279.png" alt=""><br>相比<code>Adblock Plus</code>，其实我更喜欢广告终结者这一款插件，下面来看一下他的功能。</p><ul><li><p>过滤网页上的各种类型广告</p><ul><li>百度联盟等广告联盟的广告</li><li>淘宝，天猫，京东等商城广告</li></ul></li><li><p>恶意弹窗广告</p></li><li><p>各种影响网页阅读的浮动广告</p></li><li><p>屏蔽视频广告</p><ul><li>视频片头广告</li><li>视频暂停广告</li><li>视频下方的小广告</li></ul></li><li><p>提升网页浏览体验</p><ul><li>屏蔽广告，网页排版更整齐，更易阅读</li><li>屏蔽跟踪代码，防止个人隐私泄露</li><li>过滤广告、跟踪代码，网页加载速度更快</li></ul><p><strong>看到没，他居然能屏蔽视频广告，虽然不能看vip视频，但是看视频时我又能省下60秒，岂不妙哉！！！</strong></p></li></ul><p>有时会有失效，但是你可以在插件帮助页加群会有解决方法。</p><h2 id="2、Infinity-新标签页"><a href="#2、Infinity-新标签页" class="headerlink" title="2、Infinity 新标签页"></a>2、Infinity 新标签页</h2><p>大家是否早已厌倦了360、2345、hao等一些充满广告的新标签页，一个清新的首页，总能给你打开浏览器的时候带来好的心情。</p><p>Infinity新标签页是一款基于html5的Chrome扩展程序，它重新定义了您的Chrome新标签页。<br><img src="https://img-blog.csdnimg.cn/20200322151445687.png" alt=""><br>Infinity功能简介：</p><ul><li>一 、精美的图标（logo）：扁平化设计风格，国内外200多个热门常用图标。</li><li>二、高清壁纸：从3万5千张超清壁纸中，一张一张搭配图标，精心挑选出365张，形成每日一图;当然你也可以从你自己电脑上选择图片作为壁纸。</li><li>三、云同步：时间备份数据到云端，一键从云端恢复。</li><li>四、智能邮件通知：Gmail邮件自动提醒功能。</li><li>五、待办事项：随时查看你要做的事和你做过的事。</li><li>六、个性化搜索：你可以选择你想使用的搜索引擎，你还可以定制个人的附加搜索引擎。</li><li>七、 App扩展管理：随时随地快捷方便的管理你的扩展。</li><li>八、历史记录管理：查看搜索你的记录。</li><li>九、笔记：记录生活点滴。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200322151705500.png" alt=""></p><h2 id="1、Tampermonkey（油猴）"><a href="#1、Tampermonkey（油猴）" class="headerlink" title="1、Tampermonkey（油猴）"></a>1、Tampermonkey（油猴）</h2><p>对于这款插件，我只能说一句：**牛逼，世界上最流行的用户脚本管理器，他的强大之处我就不说了，相信大家都有所体会。</p><p>Tampermonkey是最受欢迎的用户脚本管理器，拥有超过1000万用户。<br>Tampermonkey用于运行所谓的用户脚本（有时也称为Greasemonkey脚本）。用户脚本是一些小的计算机程序，例如向YouTube页面添加下载按钮、清理Facebook时间线或帮助玩在线游戏。<br><img src="https://img-blog.csdnimg.cn/20200322153211339.png" alt=""><br>对于很多人来说，这简直是白嫖党的福音啊，相信你安装了这个插件，有很多插件都可以卸载了。这里推荐几款笔者在使用的脚本，当然，你也可以自己去下载。<a href="https://greasyfork.org/zh-CN/" target="_blank" rel="noopener">传送门</a></p><ul><li>【玩的嗨】VIP工具箱</li><li>网页限制解除(改)</li><li>超星尔雅助手</li><li>百度网盘下载助手<h1 id="作者有话"><a href="#作者有话" class="headerlink" title="作者有话"></a>作者有话</h1>虽然插件给我们带来了很多方便，但是还是希望大家能够正确的用插件，尽量到官方的途径下载插件，毕竟以前就有很多插件会劫持浏览器、泄露隐私等问题。<br>最后，如果你有更好的插件，请在评论区告诉大家吧。点个赞再走吧，码字不易。<br><img src="https://img-blog.csdnimg.cn/20200405094243147.png" alt=""></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【springboot spring mybatis】看我怎么将springboot与spring整合mybatis与druid数据源</title>
      <link href="/2020/03/19/springboot-spring-mybatis-kan-wo-zen-me-jiang-springboot-yu-spring-zheng-he-mybatis-yu-druid-shu-ju-yuan/"/>
      <url>/2020/03/19/springboot-spring-mybatis-kan-wo-zen-me-jiang-springboot-yu-spring-zheng-he-mybatis-yu-druid-shu-ju-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文分别讲述了<code>spring</code>与<code>springboot</code>是怎么整合<code>mybatis</code>与<code>druid</code>数据源的？如果你只是想实现其中一种，那你就不要把他们的配置过程搞混了。<br><img src="https://img-blog.csdnimg.cn/20200319232948605.png#pic_center" alt="mybatis"></p><h2 id="1、mybatis"><a href="#1、mybatis" class="headerlink" title="1、mybatis"></a>1、mybatis</h2><p><code>MyBatis</code> 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了<code>google code</code>，并且改名为MyBatis 。2013年11月迁移到<code>Github</code>。<br><code>MyBatis</code> 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p><p>在国内以及韩国等地mybatis的普及率还是很高的。所以mybatis是绝对值得学习的。</p><h2 id="2、druid"><a href="#2、druid" class="headerlink" title="2、druid"></a>2、druid</h2><p><code>Druid</code>提供了一个高效、功能强大、可扩展性好的数据库连接池，druid还有自己的数据访问监听系统，你的系统数据调用实时状况你都一通过druid来查看。</p><h1 id="壹：spring整合"><a href="#壹：spring整合" class="headerlink" title="壹：spring整合"></a>壹：spring整合</h1><p>在整合mybatis之前，我们首先需要明确的是，我们需要哪些文件分别拿来干嘛的。</p><ul><li>1、pom.xml</li><li><ul><li>maven用于引入依赖的 </li></ul></li><li>2、jdbc.properties</li><li><ul><li>配置mybatis的数据源 </li></ul></li><li>3、mybatis-config.xml</li><li><ul><li>配置mybatis参数<h2 id="一：文件结构"><a href="#一：文件结构" class="headerlink" title="一：文件结构"></a>一：文件结构</h2>我们可以看淡我的整个的项目结构就是这样的，这里使用的是maven管理项目，直接建立<code>maven</code>项目即可，不懂maven的安装与配置的可以见我另一篇博文<a href="https://blog.csdn.net/qq_41929184/article/details/104561126" target="_blank" rel="noopener">maven的安装与配置</a>，配置好后，直接在新建项目里选择maven即可。</li></ul></li></ul><p><strong>注</strong>：我的<code>mybatis-config.xml</code>直接就是放在<code>spring-config.xml</code>，归根到地，他们都是spring的配置文件，只是命名不同而已。<br><img src="https://img-blog.csdnimg.cn/20200303122542580.png" alt="目录结构"></p><h2 id="二：配置文件"><a href="#二：配置文件" class="headerlink" title="二：配置文件"></a>二：配置文件</h2><h3 id="1、pom-xml"><a href="#1、pom-xml" class="headerlink" title="1、pom.xml"></a>1、pom.xml</h3><p><code>pom.xml</code>文件，有了这个文件之后，我们不需要像以前一样去找jar包，找到还不一定兼容，<code>maven</code>项目里，你直接在你的<code>pom.xml</code>文件里写相关依赖，他就会自动导入，<code>jar</code>包也会自动下载好，下面就是我们整合mybatis所需要的的相关依赖。</p><pre><code class="xml">&lt;!--        数据库  start--&gt;&lt;!--        引入jdbc与mysql依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.0.8&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入druid数据源--&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.8&lt;/version&gt;&lt;/dependency&gt;&lt;!--        mybatis--&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring整合mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--        数据库 end--&gt;</code></pre><h3 id="2、jdbc-properties"><a href="#2、jdbc-properties" class="headerlink" title="2、jdbc.properties"></a>2、jdbc.properties</h3><p>这个文件主要用于存放我们mybatis连接的数据库参数，依次为<strong>驱动、url、用户名、密码</strong>参数，你只需要换成你自己的就好了，设置好之后，我们需要下一个配置文件来加载。</p><pre><code>jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/world?characterEncoding=UTF-8jdbc.username=rootjdbc.password=qwer1234</code></pre><h3 id="3、mybatis-config-xml"><a href="#3、mybatis-config-xml" class="headerlink" title="3、mybatis-config.xml"></a>3、mybatis-config.xml</h3><p>这时，你会疑问，咦，上面的文件结构图中没有这个文件啊？<br>我的<code>mybatis-config.xml</code>直接就是放在<code>spring-config.xml</code>，归根到地，他们都是<code>spring</code>的配置文件，只是命名不同而已。当然，也可以单独配置一个，只需要在启动的时候加载他就可以了。</p><p>整合druid数据源，就在这个文件里配置即可。</p><pre><code class="xml">  &lt;!-- 这个是加载下面的mapper与service注入到容器中，这样你才能使用，注意你自己的包名--&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package="com.lomtom"/&gt;    &lt;!-- 配置 读取properties文件 jdbc.properties --&gt;    &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;&lt;!--        &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;--&gt;&lt;!--            &lt;property name="location" value="classpath:jdbc.properties"/&gt;--&gt;&lt;!--        &lt;/bean&gt;--&gt;    &lt;!-- 配置 数据源 整合druid--&gt;    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;        &lt;property name="driverClassName" value="${jdbc.driverClassName}" /&gt;        &lt;property name="url" value="${jdbc.url}" /&gt;        &lt;property name="username" value="${jdbc.username}" /&gt;        &lt;property name="password" value="${jdbc.password}" /&gt;    &lt;/bean&gt;&lt;!--    spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;    &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;        &lt;property name="dataSource" ref="dataSource"/&gt;        &lt;property name="mapperLocations" value="classpath:com/lomtom/mapper/*.java"/&gt;    &lt;/bean&gt;    &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;    &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;        &lt;property name="basePackage" value="com.lomtom.mapper" /&gt;        &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt;    &lt;/bean&gt;</code></pre><h2 id="二：java代码"><a href="#二：java代码" class="headerlink" title="二：java代码"></a>二：java代码</h2><h3 id="1、mapper"><a href="#1、mapper" class="headerlink" title="1、mapper"></a>1、mapper</h3><p>在<code>mybatis</code>里，支持两种写法，一种是注解版，一种是<code>xml</code>版，这里推荐使用注解版。<br><code>mybatis</code>我使用的是注解版，注解版简单。如果使用<code>xml</code>版，需要配置<code>maven</code>的静态资源访问。</p><pre><code class="java">package com.lomtom.mapper;import com.lomtom.model.User;import org.apache.ibatis.annotations.*;/** * User: lomtom * Date: 2020/3/2 * Time: 16:45 */@Mapperpublic interface UserInfoMapper {    @Select("select * from user where username = #{username} and password = #{password}")    User login(@Param("username") String username,@Param("password") String password);}</code></pre><h3 id="2、service"><a href="#2、service" class="headerlink" title="2、service"></a>2、service</h3><p>一般来说，我们为了规范，还是建一个<code>service</code>层。这里是实现service接口，你还需要自己写<code>UserInfoService</code>接口，加上<code>login();</code>函数即可，不是很难，就不板述了。</p><pre><code class="java">package com.lomtom.service;import com.lomtom.mapper.UserInfoMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * User: lomtom * Date: 2020/3/2 * Time: 17:21 */@Servicepublic class UserInfoServiceImpl implements UserInfoService {    @Autowired    UserInfoMapper userInfoMapper;    @Override    public boolean login(String username, String password) {        return userInfoMapper.login(username, password) != null;    }}</code></pre><h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><p>我使用的是<code>spring</code>测试单元测试的，需要在<code>pom.xml</code>引入<code>JUNIT</code>依赖，当然，你也可以直接写一个main函数调用。</p><p>最后的结果就不展示了，他无非就是一句登陆成功，或者登陆失败。</p><pre><code class="java">import com.lomtom.model.HelloWorld;import com.lomtom.service.UserInfoService;import org.junit.Before;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * User: lomtom * Date: 2020/3/2 * Time: 19:45 *///测试类public class test {    private ApplicationContext context;    @Before    public void setUp() throws Exception {//        加载配置文件        context = new ClassPathXmlApplicationContext("spring-config.xml");    }    @Test    public void Test2(){        UserInfoService userInfoService =  context.getBean(UserInfoService.class);        boolean flag = userInfoService.login("admin","123456");        if (flag){            System.out.println("登录成功。。。。");        }        else{            System.out.println("登陆失败。。。");        }    }}</code></pre><blockquote><p>参考：<br><a href="https://blog.csdn.net/xqhys/article/details/53994740?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">spring与mybatis四种整合方法</a></p></blockquote><h1 id="贰：springboot整合"><a href="#贰：springboot整合" class="headerlink" title="贰：springboot整合"></a>贰：springboot整合</h1><p>相对于<code>spring</code>，<code>springboot</code>的整合就简单的多，因为在springboot里，很多都是自动配置的，相当于就是对spring的再一次封装，所以在springboot里，很多东西就变得简单很多。<br>相比spring，我们不需要配置麻烦的spring配置xml文件，只需要在<code>application.yml</code>文件中配置即可。当然，pom.xml时maven所需要的，所以他也是必不可少的。<br>建立项目的时候，选择<code>spring initializr</code>就可以快速建立一个springboot项目，当然如果你想自己配置，那我也是无法阻拦的。</p><h2 id="1、pom-xml-1"><a href="#1、pom-xml-1" class="headerlink" title="1、pom.xml"></a>1、pom.xml</h2><p>springboot与spring引入mybatis所需依赖，是不同的，所以你最好还是复制这里的，这里我也是吸取了教训的。哈哈哈</p><pre><code class="java"> &lt;!--        引入jdbc与mysql依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--引入druid数据源--&gt;        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--日志打印--&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--        mybatis--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h2 id="2、application-yml（resources下）"><a href="#2、application-yml（resources下）" class="headerlink" title="2、application.yml（resources下）"></a>2、application.yml（resources下）</h2><p>与spring不同的是，在<code>springboot</code>里，不需要建很多的配置文件，你所有的配置参数全部卸载这里面即可。<br>在springboot里面，配置文件有两种，一种是<code>properties</code>，另一种是<code>yml</code>，两种语法有点不同，不过都可以作为springboot的配置文件，</p><pre><code class="yml">spring:    datasource:        username: root        password: qwer1234        url: jdbc:mysql://localhost:3306/world?serverTimezone=UTC&amp;characterEncoding=utf-8        #    不写driver-class-name则自动分配        #    driver-class-name: com.mysql.cj.jdbc.Driver        #    配置druid数据源        type: com.alibaba.druid.pool.DruidDataSourcemybatis:  #注解版与xml版不能共同使用  ##  指定全局配置的路径（xml版配置）  #  config-location: classpath::mybatis/mybatis-config.xml  ##  指定sql映射文件的位置（xml版配置）  #  mapper-locations: classpath:mybatis/mapper/*.xml  configuration:    #    开启驼峰命名法    map-underscore-to-camel-case: truelogging:  #  开启com.lomtom.blog.mapper包下所有的日志（在调用时）  level:    com.lomtom.myblog1.mapper: debug</code></pre><h2 id="3、druid配置"><a href="#3、druid配置" class="headerlink" title="3、druid配置"></a>3、druid配置</h2><p>虽然说在<code>springboot</code>里面配置数据源，但是如果我们想要通过网页端访问的话，需要配置以下内容，我们就可以通过访问<code>druid</code>的来查看web的数据状态。<br>访问地址：<code>http://localhost:8080/druid</code>，然后输入账号密码就可以访问。</p><pre><code class="java">package com.lomtom.myblog1.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;/** * User: lomtom * Date: 2020/1/4 * Time: 21:09 */@Configurationpublic class DruidConfig {    @ConfigurationProperties(prefix = "spring.datasource")    @Bean    public DataSource druid(){        return new DruidDataSource();    }    //设置druid监控    //1、设置管理后台的servlet    @Bean    public ServletRegistrationBean statViewServlet(){        ServletRegistrationBean registrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");        Map&lt;String,String&gt; initParams=new HashMap&lt;&gt;();        initParams.put("loginUsername","admin");        initParams.put("loginPassword","admin");        initParams.put("allow","");//        initParams.put("deny","");        registrationBean.setInitParameters(initParams);        return  registrationBean;    }    //2、设置web的监控filter    @Bean    public FilterRegistrationBean webStatFilter(){        FilterRegistrationBean registrationBean = new FilterRegistrationBean();        registrationBean.setFilter(new WebStatFilter());        Map&lt;String,String&gt; initParams=new HashMap&lt;&gt;();        initParams.put("exclusion","*.js,*.css,/druid/*");        registrationBean.setInitParameters(initParams);        //添加过滤规则        registrationBean.setUrlPatterns(Arrays.asList("/*"));        return  registrationBean;    }}</code></pre><p>访问<code>http://localhost:端口名/druid</code><br><img src="https://img-blog.csdnimg.cn/20200303170955151.png" alt="druid"></p><h2 id="4、mapper"><a href="#4、mapper" class="headerlink" title="4、mapper"></a>4、mapper</h2><p>在spring里面，还要配置文件进行包扫面，而在springboot里面直接加<code>@Mapper</code>注解即可，springboot会自动注册的。然后直接调用即可。</p><pre><code class="java">import com.lomtom.myblog1.entity.User;import org.apache.ibatis.annotations.*;import java.util.List;/** * User: lomtom * Date: 2020/1/30 * Time: 17:49 *//** * 用户的mapper类 */@Mapperpublic interface UserMapper {    @Select("select * from user where userName=#{username} or email=#{username}")    User getUserByUsername(String username);}</code></pre><h2 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h2><p>在spring boot里，在启动的时候不需要手动配置加载文件，所有的一切，他都会自动配置完成，你只管调用就可以了。</p><p>当然，最后的结果就不展示了，他无非就是一句登陆成功，或者登陆失败。</p><pre><code class="java">package com.lomtom.myblog1;import com.lomtom.myblog1.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass Myblog1ApplicationTests {    @Autowired    UserMapper userMapper;    @Test    void contextLoads() {        boolean flag = userMapper.login("admin","123456");        if (flag){            System.out.println("登录成功。。。。");        }        else{            System.out.println("登陆失败。。。");        }    }}</code></pre><h1 id="作者有话"><a href="#作者有话" class="headerlink" title="作者有话"></a>作者有话</h1><p>本文主要介绍了<strong>spring</strong>与<strong>springboot</strong>分别怎么整合mybatis的，相信你看了之后，如果你还是初学者，那么问题是免不了的，但是谁不是这么过来的呢，你唯一能做的就是发现问题-找到问题-解决问题，当然，如果你在配置过程中有问题，笔者还是很乐意为你解答的。</p><p>而谈及spring与spring boot，spring boot就是spring的拓展，他主要消除了spring复杂繁多的xml配置文件，实现极大程度的自动化配置，所以看到我们在整合<code>mybatis</code>时，配置变得相当简单，当然，最为笔者的建议，你要是会<code>spring boot</code>，一定要明白他其中的自动配置原理，然后再去回顾spring时，你就会惊讶的发现，哦~，原来他是这样的。很多东西就会豁然开朗。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【系统 win10 deepin】双系统安装（win10和deepin双系统）</title>
      <link href="/2020/03/12/xi-tong-win10-deepin-shuang-xi-tong-an-zhuang-win10-he-deepin-shuang-xi-tong/"/>
      <url>/2020/03/12/xi-tong-win10-deepin-shuang-xi-tong-an-zhuang-win10-he-deepin-shuang-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>所有的事情都源自于一只蝙蝠，在这个无聊且漫长的寒假，终于能够实现躺在家里也能为国家做出贡献的时候了。<br>既然闲着也是闲着，那为何不折腾一下自己的电脑呢。<br>相信很多猿在虚拟机里已经体验过linux系统，那么怎么在实体机上怎么安装深度linux系统来实现双系统呢？</p><blockquote><p>安装需求：<br>1、一台电脑<br>2、一个U盘（至少8G）<br>3、一双爱折腾的手</p></blockquote><h1 id="壹：安装win10系统"><a href="#壹：安装win10系统" class="headerlink" title="壹：安装win10系统"></a>壹：安装win10系统</h1><p>相信很多人的电脑都已经预装了win10系统，已经安装的人可以跳过这一步，但是这个也可以作为win10系统重装的记录，加入你需要给你的电脑重装win10，也可以按照这个流程来。</p><p>当然，网上有很多的教程使用第三方的工具，这里使用的是windows推荐的方法来安装纯净版的win10系统。</p><h2 id="一：下载win10系统制作工具"><a href="#一：下载win10系统制作工具" class="headerlink" title="一：下载win10系统制作工具"></a>一：下载win10系统制作工具</h2><p>进入windows<a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" rel="noopener">官方网站</a><br><img src="https://img-blog.csdnimg.cn/20200312135855938.png" alt="下载页面"></p><h2 id="二：下载系统到u盘里"><a href="#二：下载系统到u盘里" class="headerlink" title="二：下载系统到u盘里"></a>二：下载系统到u盘里</h2><p><strong>注意：此过程你的U盘会格式化，如果有资料请提前备份。</strong><br>1、打开刚刚下载的文件<br><img src="https://img-blog.csdnimg.cn/20200312140757886.png" alt="启动工具"><br>2、一切都保持默认选项就行，值得注意的几点<br>①：选择为另一台电脑创建安装介质<br><img src="https://img-blog.csdnimg.cn/20200312141015917.png" alt="选择"><br>②：选择为u盘，接下来就是一直点下一步。<br><img src="https://img-blog.csdnimg.cn/2020031214120986.png" alt="选择"></p><h2 id="三：安装win10系统"><a href="#三：安装win10系统" class="headerlink" title="三：安装win10系统"></a>三：安装win10系统</h2><p>1、插入U盘，进入安装引导</p><p>如果你的电脑没有任何系统，你点击开机键就可以直接进入安装引导界面。<br>如果你的电脑已经有系统，可以通过以下两个方法。<br>    方法一：<br>        我的电脑是开机时按f9进入，可以自己的电脑品牌自行百度，然后选择u盘。<br>    方法二：<br>        当然你也可以进入bios系统更改启动顺序，将u盘作为第一个启动，然后开机就可以了。<br>2、设置语言<br><img src="https://img-blog.csdnimg.cn/2020031214230457.png" alt=""><br>3、点击安装<br><img src="https://img-blog.csdnimg.cn/20200312142400995.png" alt=""><br>3、选择仅安装windows<br><img src="https://img-blog.csdnimg.cn/20200312142428815.png" alt=""><br>4、最重要的部分来了，选择自己的盘，可以根据大小来，因为我把win10作为主力系统，所以安装在固态银盘里。千万注意别选错了。<img src="https://img-blog.csdnimg.cn/20200312142520199.png" alt="选择分区"><br>5、就会达到这一步，接下来就是等待了，打把游戏，喝杯茶都可以，不过应该也不会太慢，速度根据自己电脑来。<br><img src="https://img-blog.csdnimg.cn/20200312142742415.png" alt=""><br>6、当你的电脑出现这个界面时，大功就告成了，接下来你只要设置一下就可以了<br><img src="https://img-blog.csdnimg.cn/20200312143007752.png" alt=""></p><h1 id="贰：安装深度deepin系统"><a href="#贰：安装深度deepin系统" class="headerlink" title="贰：安装深度deepin系统"></a>贰：安装深度deepin系统</h1><p><strong>为什么要选择deepin系统呢？</strong><br>首先，当然是deepin系统的安装过程相当简单，其次，deepin作为linux的基础的系统，已经在某些（华为）电脑上作为主力系统了，并且，deepin作为国内开发的linux系统，能够在linux排行版上达到第十的位置，说明他是非常不错的了，所以说deepin作为日常使用的系统已经足够了。</p><h2 id="一：下载deepin系统制作工具"><a href="#一：下载deepin系统制作工具" class="headerlink" title="一：下载deepin系统制作工具"></a>一：下载deepin系统制作工具</h2><p>进入deepin<a href="https://www.deepin.org/original/deepin-boot-maker/" target="_blank" rel="noopener">官网</a>，点击windows下载。<br><img src="https://img-blog.csdnimg.cn/20200312143253166.png" alt="下载工具"></p><h2 id="二：下载deepin系统镜像"><a href="#二：下载deepin系统镜像" class="headerlink" title="二：下载deepin系统镜像"></a>二：下载deepin系统镜像</h2><p>进入deepin<a href="https://www.deepin.org/download/" target="_blank" rel="noopener">官网</a>，选择镜像下载，我选择的是官方下载，速度实测还是很快的，当然你也可以选择其他的源下载，值得注意的是不要选择下方的live系统，他和win的pe系统是一样的。具体是干嘛的，请自行百度。<br><img src="https://img-blog.csdnimg.cn/20200312143424158.png" alt="镜像"><br>下载好后他是一个iso文件大概2G多<br><img src="https://img-blog.csdnimg.cn/20200312143656671.png" alt="iso镜像"></p><h2 id="二：用u盘制作启动盘"><a href="#二：用u盘制作启动盘" class="headerlink" title="二：用u盘制作启动盘"></a>二：用u盘制作启动盘</h2><p>1、打开之前下载的工具<br><img src="https://img-blog.csdnimg.cn/20200312170148633.png" alt="工具"><br>2、点击选择镜像，选择之前下载的镜像文件<br><img src="https://img-blog.csdnimg.cn/20200312170224682.png#pic_center" alt="工具"><br>3、选择u盘<br><img src="https://img-blog.csdnimg.cn/20200312170643521.png#pic_center" alt="选择u盘"></p><h2 id="三：安装deepin系统"><a href="#三：安装deepin系统" class="headerlink" title="三：安装deepin系统"></a>三：安装deepin系统</h2><p>1、给你的电脑分一个区出来，用来装deepin系统，至少16G，建议大一点，因为我的盘比较大，我分了将近100G<br>①：点击文件管理，进入磁盘管理<br><img src="https://img-blog.csdnimg.cn/20200312171057243.png" alt=""><br>②：在你的未分配的盘中新建卷，<br><img src="https://img-blog.csdnimg.cn/20200312171213436.png" alt="新建卷"><br>③：设置卷大小，建议16G以上<br><img src="https://img-blog.csdnimg.cn/20200312171403352.png" alt="设置卷大小"><br>2、进入进入启动菜单<br>方法一：<br>我的电脑是开机时按f9进入，可以自己的电脑品牌自行百度，然后选择u盘。<br>方法二：<br>当然你也可以进入bios系统更改启动顺序，将u盘作为第一个启动，然后开机就可以了。<br>3、进入deepin引导界面，点击或者直接回车<br><img src="https://img-blog.csdnimg.cn/20200312140214433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTI5MTg0,size_16,color_FFFFFF,t_70" alt="引导界面"><br>4、之后就是设置语言，时区，用户，一直到选择分区时要注意，一定要选择自己刚刚新建的分区，不要选择到其他位置了，因为他会格式化那个分区，选错小心资料不保。<br><img src="https://img-blog.csdnimg.cn/20200312171615558.png" alt=""><br>5、然后就是进入安装了，等待。。。。。。<br><img src="https://img-blog.csdnimg.cn/20200312171804405.png" alt="正在安装"></p><h1 id="叁：作者有话"><a href="#叁：作者有话" class="headerlink" title="叁：作者有话"></a>叁：作者有话</h1><p><code>Deepin</code>深度系统作为入门linux来说，还是比较不错的系统，流畅度与界面都是非常不错的，不过生态相比windows还是差了点，日常使用可能足够了。如果你想要体验的话就动手起来吧，有任何问题可以给我留言。</p><p>在最近，Deepin V20也要发布了，由于疫情的关系，往后推迟了，不过迟早会看到的。据传，Deepin V20操作系统跟由统信软件负责的国产OS系统UOS同源，UOS与Deepin V20系统是并行开发的，大部分功能及资源库都是一样的，但是两者区别UOS是面向商业用户的，Deepin v20面向社区的，个人使用不收费。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
